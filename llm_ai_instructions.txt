Node Development Reference (Full Manual)

This guide explains how to create new nodes for the visual graph system.
It covers the meta definition, frontend components (UI, inspector),
runtime integration, styling practices, and the interaction between the
app and node data. It includes examples, code templates, and integration
notes.

================================================================= 1.
Node Folder Structure
================================================================= Each
node lives in its own folder: nodes/// â”œâ”€â”€ meta.js â”œâ”€â”€ ui.jsx â”œâ”€â”€
inspector.jsx â”œâ”€â”€ process.js â””â”€â”€ index.js

-   meta.js â†’ identity, I/O, defaults.
-   ui.jsx â†’ graph view box, read-only.
-   inspector.jsx â†’ editable form for node properties.
-   process.js â†’ runtime logic.
-   index.js â†’ registers both UI and runtime.

================================================================= 2.
meta.js
=================================================================
Defines node metadata and schema. Used in frontend and backend.

Required fields: - type â†’ stable string ID (e.g.Â â€œcore.constantâ€). -
label â†’ display name. - inputs / outputs â†’ handle definitions. - config
â†’ inspector schema. - getInitialData() â†’ default node state.

Example:

export const meta = { label: â€œFormatterâ€, version: â€œ1.0.0â€, description:
â€œFormats inputs into a JSON or string template.â€, keywords: [â€œtemplateâ€,
â€œformatâ€, â€œjsonâ€, â€œstringâ€], type: â€œcore.formatterâ€, category: â€œCoreâ€,
icon: â€œğŸ§©â€, blockchains: [â€œallâ€],

inputs: [{ key: â€œinâ€, label: â€œInputsâ€, type: â€œanyâ€ }], outputs: [{ key:
â€œvalueâ€, label: â€œValueâ€, type: [â€œstringâ€, â€œobjectâ€] }],

config: [ { key: â€œmodeâ€, label: â€œModeâ€, type: â€œenumâ€, options: [â€œjsonâ€,
â€œstringâ€], default: â€œjsonâ€ }, { key: â€œtemplateâ€, label: â€œTemplateâ€,
type: â€œstringâ€, default: â€œ{}â€ } ],

getInitialData: () => ({ mode: â€œjsonâ€, template: â€œ{}â€ }),

isDeterministic: true, hasSideEffects: false, };

================================================================= 3.
ui.jsx (Graph Canvas View)
=================================================================
Lightweight, read-only representation of a node.

-   Shows title, labels, previews, and status.
-   Exposes React Flow handles for connections.
-   No editing inside the node.

Styling conventions: - Padding: 12px - Border: 1px solid #cbd5e1 -
Border radius: 10px - Background: white - Small â€œpillâ€ labels for
type/mode/status - Monospace fonts for previews

Example:

import { Handle, Position } from â€œ@xyflow/reactâ€;

export default function FormatterNode({ data }) { const mode =
data?.mode || â€œjsonâ€; const varsCount =
Array.isArray(data?.availableParams) ? data.availableParams.length : 0;
const valid = mode === â€œstringâ€ ? true :
validateJsonTemplate(data?.template);

return ( <div style={{ padding: 12, borderRadius: 10, border: â€œ1px solid
#cbd5e1â€, background: â€œwhiteâ€, minWidth: 220 }}> <div style={{ display:
â€œflexâ€, alignItems: â€œcenterâ€, gap: 8 }}> <div style={{ fontWeight: 800
}}>Formatter
        <ModePill mode={mode} />
      </div>
      <div style={{ fontSize: 12 }}>Variables: {varsCount}</div>
      <div style={{ fontSize: 12 }}>Status: <span style={{ color: valid ? "#16a34a" : "#dc2626" }}>{valid ? "Valid" : "Invalid"}</span></div>

      <Handle id="in" type="target" position={Position.Left} />
      <Handle id="value" type="source" position={Position.Right} />
    </div>

); }

================================================================= 4.
inspector.jsx (Sidebar Editor)
=================================================================
Interactive editor for node properties.

-   Receives { node, value, onChange }
-   value = node.data
-   onChange(nextData) updates graph state
-   Keeps local state synced with node.data
-   Handles validation and previews

Formatter example features: - Toggle JSON / String mode - Textarea for
template - Auto-populated variable list from connected nodes - Click
inserts {{token}} into textarea

================================================================= 5.
process.js
=================================================================
Runtime execution logic.

-   Exports run({ inputs, data, context })
-   Must return object keys matching outputs in meta.js

Example:

export async function run({ inputs, data }) { const mode = data?.mode ||
â€œjsonâ€; const template = data?.template || â€œâ€œ;

const vars = { â€¦inputs }; let out = template; for (const [key, val] of
Object.entries(vars)) { out = out.replaceAll({{${key}}}, String(val)); }

if (mode === â€œjsonâ€) { try { return { value: JSON.parse(out) }; } catch
{ return { value: null }; } } return { value: out }; }

================================================================= 6.
index.js
=================================================================
Registers node with frontend and runtime.

Example:

import { meta } from â€œ./meta.jsâ€; import UI from â€œ./ui.jsxâ€; import
Inspector from â€œ./inspector.jsxâ€; import { run } from â€œ./process.jsâ€;

export function registerFrontend({ nodeTypes, inspectorRegistry,
nodePalette }) { nodeTypes[meta.type] = UI; inspectorRegistry[meta.type]
= Inspector; nodePalette.push({ type: meta.type, label: meta.label,
icon: meta.icon, getData: meta.getInitialData, category: meta.category
}); }

export function registerRuntime({ handlers }) { handlers.set(meta.type,
{ run }); }

================================================================= 7. App
â†” Node Data Flow
================================================================= -
Graph stores nodes/edges in state. Each node has .data - Inspector edits
.data via onChange - NodeInspector wires inspector into graph state -
FlowCanvas recomputes node.data.availableParams when edges change
(onConnect, onEdgesChange)

Formatter variable example: - When a Constant is connected, FlowCanvas
updates Formatter.data.availableParams with { name, type, src, preview
} - Inspector renders variables list dynamically

================================================================= 8.
Styling Guidelines
================================================================= -
Borders: 1px solid #cbd5e1 - Shadows: 0 1px 4px rgba(0,0,0,0.06) -
Fonts: system-ui for labels, ui-monospace for previews - Pills/tags:
border 1px solid #e2e8f0, background #f8fafc - Buttons: radius 8px,
border 1px solid #cbd5e1 - Textareas: monospace, minHeight 200px

================================================================= 9.
Templates (for fast copy/paste)
=================================================================

meta.js template:

export const meta = { label: â€œNewNodeâ€, version: â€œ1.0.0â€, description:
â€œDescribe functionâ€, keywords: [], type: â€œcore.newnodeâ€, category:
â€œCoreâ€, inputs: [], outputs: [{ key: â€œvalueâ€, label: â€œValueâ€, type:
â€œanyâ€ }], config: [], getInitialData: () => ({}), isDeterministic: true,
hasSideEffects: false, };

ui.jsx template:

import { Handle, Position } from â€œ@xyflow/reactâ€; export default
function NewNode({ data }) { return ( <div style={{ padding: 12, border:
â€œ1px solid #cbd5e1â€, borderRadius: 10, background: â€œwhiteâ€ }}> <div
style={{ fontWeight: 800 }}>NewNode
      <Handle id="value" type="source" position={Position.Right} />
    </div>

); }

inspector.jsx template:

export default function NewNodeInspector({ node, value, onChange }) {
return ( <div style={{ display: â€œgridâ€, gap: 10 }}> <div style={{
fontWeight: 800 }}>NewNode
      {/* Add form inputs here */}
    </div>

); }

process.js template:

export async function run({ inputs, data }) { return { value:
data?.value ?? null }; }

index.js template:

import { meta } from â€œ./meta.jsâ€; import UI from â€œ./ui.jsxâ€; import
Inspector from â€œ./inspector.jsxâ€; import { run } from â€œ./process.jsâ€;

export function registerFrontend({ nodeTypes, inspectorRegistry,
nodePalette }) { nodeTypes[meta.type] = UI; inspectorRegistry[meta.type]
= Inspector; nodePalette.push({ type: meta.type, label: meta.label,
getData: meta.getInitialData, category: meta.category }); }

export function registerRuntime({ handlers }) { handlers.set(meta.type,
{ run }); }
